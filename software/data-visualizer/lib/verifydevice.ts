import prisma from "@/lib/prisma";
import { decryptSecret } from "@/lib/crypto";
import crypto from "crypto";

/**
 * Device Verification Module
 * * PURPOSE:
 * Validates that an incoming request was generated by a legitimate hardware device
 * possessing the correct unique secret. This prevents unauthorized uploads/spoofing.
 * * SECURITY ARCHITECTURE:
 * 1. STORAGE (At Rest):
 * - The unique device secret is stored in the database encrypted via AES-256-GCM.
 * - It is decrypted only momentarily during this verification process using the
 * server's DEVICE_SECRET_ENCRYPTION_KEY (from .env).
 * * 2. TRANSMISSION (In Transit):
 * - The device never sends the secret over the network.
 * - Instead, it uses the secret to generate an HMAC-SHA256 signature.
 * - This function re-calculates that signature to verify authenticity.
 * * SIGNATURE ALGORITHM:
 * Signature = HMAC_SHA256(Key=DeviceSecret, Data=StringToSign)
 * StringToSign = `${deviceId}:${timestamp}:${nonce}:${SHA256(payload)}`
 * * REQUIRED HEADERS:
 * - x-timestamp: Unix timestamp (seconds) to prevent replay attacks (>5min rejection).
 * - x-nonce:     Random value to ensure uniqueness.
 * - x-signature: The hex-encoded HMAC string calculated by the device.
 */

export async function verifyDeviceSignature(
  deviceId: string,
  headers: Headers,
  payloadToVerify: string,
): Promise<{ success: boolean; message?: string }> {
  const timestamp = headers.get("x-timestamp");
  const nonce = headers.get("x-nonce");
  const signature = headers.get("x-signature");

  if (!timestamp || !nonce || !signature) {
    return { success: false, message: "Missing security headers" };
  }

  const deviceRecord = await prisma.deviceSecret.findUnique({
    where: { deviceId },
  });

  if (!deviceRecord) {
    return {
      success: false,
      message: "Device not provisioned",
    };
  }

  let secret = "";
  try {
    secret = decryptSecret(deviceRecord.secret);
  } catch (e) {
    console.error("Decryption failed for device", deviceId);
    return { success: false, message: "Server error during auth" };
  }

  const payloadHash = crypto
    .createHash("sha256")
    .update(payloadToVerify)
    .digest("hex");

  const stringToSign = `${deviceId}:${timestamp}:${nonce}:${payloadHash}`;

  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(stringToSign)
    .digest("hex");

  if (signature !== expectedSignature) {
    console.warn(
      `[Auth] Fail for ${deviceId}.\nExpected: ${expectedSignature}\nGot: ${signature}`
    );
    return { success: false, message: "Invalid signature" };
  }

  return { success: true };
}
