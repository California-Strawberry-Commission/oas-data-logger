import prisma from "@/lib/prisma";
import { decryptSecret } from "@/lib/crypto";
import crypto from "crypto";

/**
 * Device Verification Module
 * * PURPOSE:
 * Validates that an incoming request was generated by a legitimate hardware device
 * possessing the correct unique secret. This prevents unauthorized uploads/spoofing.
 * * SECURITY ARCHITECTURE:
 * 1. STORAGE (At Rest):
 * - The unique device secret is stored in the database encrypted via AES-256-GCM.
 * - It is decrypted only momentarily during this verification process using the
 * server's DEVICE_SECRET_ENCRYPTION_KEY (from .env).
 * * 2. TRANSMISSION (In Transit):
 * - The device never sends the secret over the network.
 * - Instead, it uses the secret to generate an HMAC-SHA256 signature.
 * - This function re-calculates that signature to verify authenticity.
 * * SIGNATURE ALGORITHM:
 * Signature = HMAC_SHA256(Key=DeviceSecret, Data=StringToSign)
 * StringToSign = `${deviceId}:${timestamp}:${nonce}:${SHA256(payload)}`
 * * REQUIRED HEADERS:
 * - x-timestamp: Unix timestamp (seconds) to prevent replay attacks (>5min rejection).
 * - x-nonce:     Random value to ensure uniqueness.
 * - x-signature: The hex-encoded HMAC string calculated by the device.
 */
export async function verifyDeviceSignature(
  deviceId: string,
  headers: Headers,
  payloadToVerify?: string,
): Promise<{ success: boolean; message?: string }> {
  // First try dev bypass
  const bypass = checkDevBypass(headers);
  if (bypass) {
    console.warn(`[verifyDeviceSignature] Dev bypass used`);
    return { success: true };
  }

  // Normal device auth
  const timestamp = headers.get("x-timestamp");
  const nonce = headers.get("x-nonce");
  const signature = headers.get("x-signature");

  if (!timestamp || !nonce || !signature) {
    return { success: false, message: "Missing security headers" };
  }

  const deviceRecord = await prisma.deviceSecret.findUnique({
    where: { deviceId },
  });

  if (!deviceRecord) {
    return {
      success: false,
      message: "Device not provisioned",
    };
  }

  let secret = "";
  try {
    secret = decryptSecret(deviceRecord.secret);
  } catch (err: any) {
    console.error(
      "[verifyDeviceSignature] Decryption failed for device",
      deviceId,
      err,
    );
    return { success: false, message: "Server error during auth" };
  }

  const payloadHash = crypto
    .createHash("sha256")
    .update(payloadToVerify ?? "")
    .digest("hex");

  const stringToSign = `${deviceId}:${timestamp}:${nonce}:${payloadHash}`;

  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(stringToSign)
    .digest("hex");

  if (signature !== expectedSignature) {
    return { success: false, message: "Invalid signature" };
  }

  return { success: true };
}

function checkDevBypass(headers: Headers): boolean {
  // Never allow bypass in production
  if (process.env.NODE_ENV === "production") {
    return false;
  }

  const expectedKey = process.env.AUTH_DEV_KEY;
  const providedKey = headers.get("x-dev-key");
  if (!expectedKey || !providedKey || expectedKey !== providedKey) {
    return false;
  }

  return true;
}
