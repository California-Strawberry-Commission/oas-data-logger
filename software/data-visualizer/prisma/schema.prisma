generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ------------------------------------------------------------
// User and device management
// ------------------------------------------------------------

enum AppRole {
  ADMIN
  USER
}

enum DeviceRole {
  VIEWER
  // Will add more in the future
}

model User {
  id           String  @id @default(cuid(2))
  email        String  @unique
  passwordHash String
  role         AppRole @default(USER)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userDevices UserDevice[]
}

model Device {
  id   String  @id
  name String?

  secret DeviceSecret? // optional because device might be created before provision

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userDevices UserDevice[]
  runs        Run[]
}

model DeviceSecret {
  deviceId String @id

  // This stores the encrypted secret.
  secret String

  encryptionKeyVersion Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation fields
  device Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)
}

model UserDevice {
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   String // relation field
  device   Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId String // relation field

  role DeviceRole @default(VIEWER)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([userId, deviceId]) // each user-device pair is unique
  @@index([deviceId, role])
  @@index([userId, role])
}

// ------------------------------------------------------------
// Runs and stream data
// ------------------------------------------------------------

enum StreamType {
  POLLED
  EVENT
}

model Run {
  id         Int     @id @default(autoincrement())
  uuid       String  @unique
  device     Device  @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  deviceId   String // relation field
  epochTimeS BigInt
  tickBaseUs BigInt
  metadata   Json
  isActive   Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  runData RunData[]
}

model RunData {
  id         Int        @id @default(autoincrement())
  run        Run        @relation(fields: [runId], references: [id], onDelete: Cascade)
  runId      Int // relation field
  streamType StreamType
  streamId   String
  tick       BigInt
  data       String

  @@index([runId, streamType, streamId, tick])
}

// ------------------------------------------------------------
// OTA releases
// ------------------------------------------------------------

enum DeviceType {
  V0
  V1
}

enum OtaChannel {
  STABLE
  BETA
}

model FirmwareRelease {
  id          String     @id @default(cuid(2))
  deviceType  DeviceType
  channel     OtaChannel @default(STABLE)
  buildNumber Int // monotonic version number
  version     String // human readable version name
  sha256      String // 64 hex chars
  size        Int // in bytes
  s3Key       String
  isPublished Boolean    @default(false)

  createdAt   DateTime  @default(now())
  publishedAt DateTime?

  @@unique([deviceType, channel, buildNumber])
  @@index([deviceType, channel, isPublished, buildNumber])
}
